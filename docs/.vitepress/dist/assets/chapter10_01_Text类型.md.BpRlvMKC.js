import{_ as a,c as l,o as n,j as e,a as r}from"./chunks/framework.DPDPlp3K.js";const m=JSON.parse('{"title":"10.1.4 Text类型","description":"","frontmatter":{},"headers":[],"relativePath":"chapter10/01/Text类型.md","filePath":"chapter10/01/Text类型.md","lastUpdated":null}'),o={name:"chapter10/01/Text类型.md"};function d(i,t,s,c,u,x){return n(),l("div",null,t[0]||(t[0]=[e("h1",{id:"_10-1-4-text类型",tabindex:"-1"},[r("10.1.4 Text类型 "),e("a",{class:"header-anchor",href:"#_10-1-4-text类型","aria-label":'Permalink to "10.1.4 Text类型"'},"​")],-1),e("ul",null,[e("li",null,'nodeName 的值为"#text"。'),e("li",null,"nodeValue 的值为节点所包含的文本。"),e("li",null,"可以通过 nodeValue 属性或 data 属性访问(修改) Text 节点中包含的文本。"),e("li",null,"一般情况下，每个元素只有一个文本子节点。不过，在某些情况下也可能包含多个文本子节点。"),e("li",null,"如果在一个包含两个或多个文本节点的父元素上调用 normalize()方法，则会将所有文本节点合并成一个节点，结果节点的 nodeValue 等于将合并前每个文本节点的 nodeValue 值拼接起来的值。"),e("li",null,"可以使用 document.createTextNode()创建新文本节点，这个方法接受一个参数——要插入节点中的文本。"),e("li",null,"Text 类型提供了一个作用与 normalize()相反的方法： splitText()。这个方法会将一个文本节点分成两个文本节点。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。")],-1)]))}const _=a(o,[["render",d]]);export{m as __pageData,_ as default};
