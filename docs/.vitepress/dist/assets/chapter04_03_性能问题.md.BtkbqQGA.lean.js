import{_ as t,c as r,o as l,j as e,a as o}from"./chunks/framework.DPDPlp3K.js";const f=JSON.parse('{"title":"性能问题","description":"","frontmatter":{},"headers":[],"relativePath":"chapter04/03/性能问题.md","filePath":"chapter04/03/性能问题.md","lastUpdated":null}'),n={name:"chapter04/03/性能问题.md"};function s(c,a,p,d,i,_){return l(),r("div",null,a[0]||(a[0]=[e("h1",{id:"性能问题",tabindex:"-1"},[o("性能问题 "),e("a",{class:"header-anchor",href:"#性能问题","aria-label":'Permalink to "性能问题"'},"​")],-1),e("p",null,"垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。",-1),e("p",null,"IE 的垃圾收集器是根据内存分配量运行的，具体一点说就是256 个变量、4096 个对象（或数组）字面量和数组元素（slot）或者64KB 的字符串。达到上述任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频繁地运行。",-1),e("p",null,"事实上，在有的浏览器中可以触发垃圾收集过程，但我们不建议读者这样做。在IE 中，调用window.CollectGarbage()方法会立即执行垃圾收集。在Opera 7 及更高版本中，调用window.opera.collect()也会启动垃圾收集例程。",-1)]))}const h=t(n,[["render",s]]);export{f as __pageData,h as default};
